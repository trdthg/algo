# 2021-2022（2）算法设计与分析复习提纲

## 本届题型：

1. 单选题（2*5=10 分）
2. 多选题（4*5=20 分）
3. 填空题（2*5=10 分）
4. 算法补充题（2*5=10 分）
5. 算法理解题（3 题，28 分）
6. 算法设计与分析题（2 题，22 分）

## 第一章

### 算法的定义

1. 定义

- 算法是解决问题的一种方法或一个过程
- 算法是若干指令的有穷序列，其中每一条指令代表一个或者多个操作
- 算法是求解一个问题类的二异性的有穷过程

### 算法时间复杂度的分类，计算及规则

- 最坏 | 最好 | 平均情况下的时间复杂度

- for / while：循环内的计算时间 × 循环次数
- 嵌套循环：循环体内的计算时间 × 所有循环次数
- 顺序：各语句相加
- if-else：较大者

- O(f) + O(g) = O(max(f, g))
  - O(n^2) + O(n) = O(max(n^2, n))
- O(f) + O(g) = O(f + g)
  - O(n^2) + O(n) = O(n^2 + n)
- O(f)O(g) = O(f * g)
  - O(n^2)O(n) = O(n^2 * n)

### 算法的性质

2. 性质

- 输入：0 个或多个外部量
- 输出：至少 1 个
- 确定性：组成算法的每条指令是清晰的，无歧义的
- 有限性：每条指令的执行次数是有限的，执行每条指令的时间也是有限的
- 可行性：一个算法应该是能行的

### 时间复杂度和空间复杂度的计算

## 第二章

### 分治的基本思想

特征：

- 该问题的规模缩小到一定的程度就可以容易地解决
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。
- 利用该问题分解出的子问题的解可以合并为该问题的解；
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。

### 分治的基本步骤、特点

2、分治法的求解过程？分治法通常采用递归算法设计技术，在每一层递归上都有 3 个步骤：

- 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。
- 解决：递归的求解子问题，当问题规模足够小是直接求解
- 合并

一般分成大小相同的 K 份，源自平衡子问题的思想

### 递归公式的推导（过程、结论）

- T(n) =
  - 1 n = 1
  - kT(n / k) + f(n) n > 1 f(n) 表示合并的时间

- 设置分解阈值为 1，解规模为 1 的问题需要 1 个单位时间
- 将原有问题分解为 k 个，以及合并所需 f(n) 个单位时间
- T(n) 为规模为 n 的问题的计算时间

### 应用：

- 斐波那契（递归关系 ，算法）、
  - F(n) = 1 n = 0 1 n = 1 F(n - 1) + F(n - 2) n > 1
- 二分搜索（算法、时间复杂度 logn）、

```c
while (l <= r) {
  mid = l + (r - l) / 2;
  if (target == mid) return mid;
  if (target < mid) r = mid - 1;
  if (target > mid) l = mid + 1;
}
```

- 快速排序 (算法、时间复杂度 nlogn n^2)、

```c
void sort(int* nums, int len, int l, int r) {

  int guard = nums[l]
  while (l < r) {
    while (l < r && nums[r] >= guard) {
      r -= 1;
    }
    if (l < r) {
      nums[l] = nums[r];
    }
    while(l < r && nums[l] <= guard) {
      l += 1;
    }
    if (l < r) {
      nums[r] = nums[l];
    }
  }
  nums[l] = guard;
  sort(nums, len, l, mid - 1);
  sort(nums, len, mid + 1, r);
}
```

- 合并排序 (算法、时间复杂度 nlogn)、

```c
void merge_two_array(int *nums, int l, int mid, int r) {
  int* tmp = malloc(sizeof(int) * (r - l));
  int s1 = l;
  int s2 = mid + 1;
  while (l < mid && s2 < r) {
    if (nums[s1] < nums[s2]) {
      tmp[i] = nums[s1]
      s1 += 1;
    }
    else {
      tmp = nums[s2]
      s2 += 1;
    }
  }
}

void sort(int* nums, int len, int l, int r) {
  int mid = l + (r - l) / 2
  sort(nums, len, l, mid);
  sort(nums, len, mid + 1, r);
  merge_two_array(nums, l, mid, r);
}
```

- 大整数乘法、
- 棋盘覆盖问题

## 第三章

### 贪心法的基本思想

从问题的初始状态出发，通过若干次贪心选择，得出问题的最优解或近似优解。

### 贪心法的特点、基本要素

- 总是作出当前最好的选择
- 不从整体考虑，只是某种意义上的局部最优选择
- 只是希望最终结果也是最优解
- 不能对所有问题都找到最优解，但是很多都可以，比如（单源最短路径，最小生成树）
- 最优解的很好近似

基本要素：

- 最优子结构性质
- 贪心选择性质

### 应用：

- 最小生成树、
- 单源最短路径（求解过程，填表）、
- 最优装载问题（算法、算法时间复杂度 (主要在排序，所以是 nlogn)、算法正确性证明）、重量

```c
for (int i = 1; i < n; i++) {
  c -= w[i]
  if (c < 0) {
    break;
  }
  cnt += 1;
}
```

<!-- - 分数背包问题（算法、算法时间复杂度、算法正确性证明）、单位质量价值 Vi / Wi -->

- 活动安排（算法、算法时间复杂度、算法正确性证明）结束早的在前

```c
for (int i = 2; i <= len; i++) {
  if (S[i] >= f[result[cnt]) {
    cnt += 1;
    result[cnt] = i;
  }
}
```

## 第四章

### 动态规划的基本思想

每个字问题只求解一次，不管是否会再次遇到，都将其结果保存在一张表中避免重复计算，从而得到多项式时间算法

<!-- 重复的子问题，第一次遇见之后就保存起来，再次遇见就直接引用，不必重新求值。 -->

常用来解决最优解问题

### 动态规划解题的四个步骤

- 找到最优解性质，并刻画其结构特征
- 递归的定义最优解
- 自底向上计算出最优解
- 根据计算最优解时得到的信息，构造出最优解

### 动态规划的两个基本要素

- 最优子结构（/动归的前提）
- 重叠子问题

### 应用

- 投资问题（递归关系、算法）
 
- 0-1 背包问题（递归关系、算法）

- 最长公共子序列（递归关系、算法）
- 矩阵连乘（递归关系、算法）

## 第五章 // 飞抵鬼

### 回溯法的基本思想

- 确定了解空间的组织结构后，回溯发就从开始节点（跟节点）出发，以深度优先的方式搜索解空间。
- 深度优先 的 问题状态 的 生成方法
  - 对拓展节点 R，一旦产生了一个子节点 C，C 就是新的拓展节点
  - 完成对 C 的穷尽搜索后，R 就重新变成拓展节点
  - 在一个拓展节点变成死节点前，他都是拓展节点
- 回溯法递归的在解空间中搜索，知道找到要求的解，或者是没有活节点为止。

- 拓展节点：正在生成儿子的节点

<!-- 试探 -->

- 活节点：自己已经生成，但儿子尚未生成的节点

<!-- 回溯 -->

- 死节点：所有儿子都已经产生

### 回溯法解题步骤

- 为了避免那些不可能产生最佳解的问题状态，
- 利用剪枝函数剪掉一些活节点，减少计算量

### 剪枝函数的作用及分类

- 约束函数：剪去不满足的子树（大于背包容量）
- 限界函数：剪去得不到最优解的子树（低于最大价值）

- 0-1 背包 子集树
- 旅行商问题排列树

### 应用：

- 0-1 背包问题（解空间树，画解空间树中的搜索过程，解的形式，约束，目标、算法）
  - 解空间是子集树
- n 后问题（解的形式，约束）

```c
s[1] = 0;
int k = 1;
while(k > 0) {
  s[k] += 1;
  // 限界函数
  while (s[k] <= n && !is_valid(s, n, k)) s[k] += 1;
  // 约束函数
  if (s[k] > n) {
    s[k] = 0;
    k--;
  }
  if (s[k] == n) {
    *sum += 1;
  } else {
    k ++;
  }
}
```

- 图的 M 着色（解的形式，约束，算法）、
- 装载问题（解的形式，算法）。

## 第六章

### 分支限界法的基本思想及搜索方式

- 广度优先，或者最小耗费（最大收益）优先进行搜索的解空间树。
- 每个活节点只有 1
  次机会产生所有儿子节点，活节点一旦成为拓展节点，就会一次性产生所有儿子节点。，在这些儿子节点中，导致不可行解或者非最优解的会被舍弃，其余的加入到活节点表中。
- 从表中取下一个成为拓展节点，重复
- 知道拿到解，或者表为空 2

### 分支限界法与回溯法的比较

- 回溯： 找到满足的所有解

- 分支界限：找到满足的一个结，或者是满足的解中的最优解

### 常见的两种分支限界法

- 队列先进显出 FIFO
- 优先队列：优先级最高的成为拓展节点

### 应用

- 0-1 背包问题
- 旅行商问题
- 装载问题

## 答疑

- 复杂度计算
- 分治的递归表达式
  - | 活动安排
  - | 最优装载
